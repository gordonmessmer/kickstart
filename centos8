#version=RHEL8
ignoredisk --only-use=vda
# Partition clearing information
clearpart --none --initlabel
# Use graphical install
text
# Keyboard layouts
keyboard --vckeymap=us --xlayouts='us'
# System language
lang en_US.UTF-8

# Network information
network  --bootproto=dhcp --device=eth0 --ipv6=auto --no-activate
network  --hostname=localhost.localdomain
# Root password
rootpw password
# Run the Setup Agent on first boot
firstboot --disable
# Do not configure the X Window System
skipx
# System services
services --disabled="chronyd"
# System timezone
timezone America/Los_Angeles --isUtc --nontp

url --url=http://mirror.facebook.net/centos-stream/8-stream/BaseOS/x86_64/os/

# Partition Information
# Generated by the "pre" script:
%include /tmp/ks-include

%packages
@^minimal-environment
@standard
kexec-tools

%end

%addon com_redhat_kdump --enable --reserve-mb='auto'

%end

%anaconda
pwpolicy root --minlen=6 --minquality=1 --notstrict --nochanges --notempty
pwpolicy user --minlen=6 --minquality=1 --notstrict --nochanges --emptyok
pwpolicy luks --minlen=6 --minquality=1 --notstrict --nochanges --notempty
%end

%post

case " $(cat /proc/cmdline)" in
	*\ sshkey=\'*)
		sshkey="$(cat /proc/cmdline)"
		sshkey="${sshkey##*sshkey=\'}"
		sshkey="${sshkey%%\'*}"
		mkdir /root/.ssh
		echo "$sshkey" >> /root/.ssh/authorized_keys
		chmod 0700 /root/.ssh
		chmod 0600 /root/.ssh/authorized_keys
		;;
esac

%end

%pre

wipedisks() {
	vgchange -a n
	test -b /dev/md/efi && wipefs -a --force /dev/md/efi && mdadm --stop /dev/md/efi
	test -b /dev/md/boot && wipefs -a --force /dev/md/boot && mdadm --stop /dev/md/boot
	test -b /dev/md/primary && wipefs -a --force /dev/md/primary && mdadm --stop /dev/md/primary
	for x in /dev/md/*
	do
		mdadm --stop $x
	done
	for x in ${drives[@]}
	do
		for p in /dev/${x}[0-9]* /dev/${x}p[0-9]*
		do
			test -b "$p" && wipefs -a $p
		done
		wipefs -a $x
	done
}

n_or_p() {
	test -b "/dev/${1}${2}" && echo "${1}${2}" && return
	test -b "/dev/${1}p${2}" && echo "${1}p${2}" && return
}

partition_drive() {
	parted -s "$1" mklabel gpt \
		mkpart primary ext4 1M 200M \
		mkpart primary ext4 200M 1224M \
		mkpart primary ext4 1224M 100%
	test -d /sys/firmware/efi || parted -s "$1" set 1 bios_grub on
}

partition_drives() {
	for x in ${drives[@]}
	do
		partition_drive /dev/$x
	done
}

create_raid () {
	level="$1"
	ndevs="${#drives[@]}"
	declare -a mdparts

	if test "$level" = 5 -o "$level" = 6
	then
		chunk=--chunk=64
	fi
	for x in "${drives[@]}"
	do
		mdparts+=("/dev/$(n_or_p ${x} 3)")
	done

	if test -d /sys/firmware/efi
	then
		mdadm --create /dev/md/efi --run --level=1 --raid-devices=2 --metadata=1.0 "/dev/$(n_or_p ${drives[0]} 1)" "/dev/$(n_or_p ${drives[1]} 1)"
	fi
	mdadm --create /dev/md/boot --run --level=1 --raid-devices=2 --metadata=1.0 "/dev/$(n_or_p ${drives[0]} 2)" "/dev/$(n_or_p ${drives[1]} 2)"
	mdadm --create /dev/md/primary --run --level="$level" --raid-devices="$ndevs" --metadata=1.2 --bitmap=internal $chunk "${mdparts[@]}"
}

ksbootloader() {
	cat <<EOF

# Boot Loader Options
bootloader --location=mbr --append="net.ifnames=0 biosdevname=0" ${1}

EOF
}

ksbootpartition() {
	if test -d /sys/firmware/efi
	then
		if test -e /dev/md/efi
		then
			echo "raid /boot/efi --device=efi --useexisting --fstype=efi --label EFI"
		else
			echo "part /boot/efi --onpart=$(n_or_p ${drives[0]} 1) --fstype=efi --label EFI"
		fi
	else
		echo "part biosboot --onpart=$(n_or_p ${drives[0]} 1) --fstype=biosboot"
	fi
}

# Partitions for hosts with software RAID
kspartitions_raid () {
	partition_drives
	create_raid "$1"
	ksbootpartition

	cat <<EOF
raid /boot --device=boot --useexisting --fstype=ext4
raid pv.01 --device=primary --useexisting
EOF
}

# Partitions for hosts with one disk
kspartitions_noraid () {
	partition_drives
	ksbootpartition

	cat <<EOF
part /boot --fstype=ext4 --onpart=$(n_or_p ${drives} 2)
part pv.01 --onpart=$(n_or_p ${drives} 3)
EOF
}

# Filesystems for non-KVM host systems
ksfilesystems_common () {
	cat <<EOF
volgroup VolGroup pv.01 --reserved-percent=10
logvol / --vgname=VolGroup --name=lv_root --fstype=ext4 --size=10240
logvol swap --vgname=VolGroup --name=lv_swap --size=2048
logvol /var --vgname=VolGroup --name=lv_var --fstype=ext4 --size=1024 --grow
EOF
}

# Filesystems for KVM hosts, limit /var to 40G; any remaining space in the VG will be for guests
ksfilesystems_kvm () {
	cat <<EOF
volgroup VolGroup pv.01 --reserved-percent=10
logvol / --vgname=VolGroup --name=lv_root --fstype=ext4 --size=10240
logvol swap --vgname=VolGroup --name=lv_swap --size=2048
logvol /var --vgname=VolGroup --name=lv_var --fstype=ext4 --size=40960
EOF
}

# Filesystems for workstation hosts, limit /var to 40G; increase / and swap
ksfilesystems_ws () {
	cat <<EOF
volgroup VolGroup pv.01 --reserved-percent=10
logvol / --vgname=VolGroup --name=lv_root --fstype=ext4 --size=20480
logvol swap --vgname=VolGroup --name=lv_swap --size=2048 --grow
logvol /var --vgname=VolGroup --name=lv_var --fstype=ext4 --size=40960
EOF
}

kspartitions () {
	case " $(cat /proc/cmdline)" in
		*\ pcie_aspm=off*)
			ksbootloader --append="pcie_aspm=off processor.max_cstate=1 clocksource=tsc"
			;;
		*)
			ksbootloader
			;;
	esac
	case " $(cat /proc/cmdline)" in
		*\ wipedisks*)
			wipedisks > /dev/null 2>&1
			;;
	esac
	case " $(cat /proc/cmdline)" in
		*\ softraid10*)
			kspartitions_raid 10
			;;
		*\ softraid6*)
			kspartitions_raid 6
			;;
		*\ softraid5*)
			kspartitions_raid 5
			;;
		*\ softraid*)
			kspartitions_raid 1
			;;
		*)
			kspartitions_noraid
			;;
	esac
	case " $(cat /proc/cmdline)" in
		*\ kvm*)
			ksfilesystems_kvm
			;;
		*\ workstation*)
			ksfilesystems_ws
			;;
		*)
			ksfilesystems_common
			;;
	esac
}

# Determine which disk is available
declare -a drives
case " $(cat /proc/cmdline)" in
	*\ drives=*)
		for x in $(cat /proc/cmdline)
		do
			test "drives=" = "${x:0:7}" || continue
			d=${x:7}
			drives+=( ${d/,/ } )
		done
		;;
	*)
		pushd /sys/block
		test -e nvme0n1 && for x in nvme*
		do
			drives+=($x)
		done
		test -e sda && for x in sd*
		do
			drives+=($x)
		done
		test -e hda && for x in hd*
		do
			drives+=($x)
		done
		test -e xvda && for x in xvd*
		do
			drives+=($x)
		done
		test -e vda && for x in vd*
		do
			drives+=($x)
		done
		popd
		;;
esac

# Build the include file
test -n "${drives}" && kspartitions >> /tmp/ks-include

%end
